# MaintenanceTracker
.NET 8 Blazor web application used to maintain internal database with a list of up to 10 vehicles


## Prominent Technologies Used

1. Microsoft's SQLite
    * Used to maintain small internal SQLite database for Vehicles, as well as all logs generated by application
2. Serilog's Serilog.Sinks.SQLite
    * Used to link all application logging to the internal SQLite 
3. Microsoft's CommunityToolkit.MVVM
    * Used to generate ObservableObject boilderplate code and other OnPropertyChanged handlers automatically to allow data-binding to the list of vehicles
4. Dapper Micro-ORM
    * Used to interact with the SQLite database 
6. Radzen Blazor
    * Blazor Component and CSS Theme Library used to style page, as well as provide custom interactivity within the app
    * Examples include Toast-style notifications, Modal handling, DataGrid components, Entry Fields, etc.
7. XUnit/BUnit
    * XUnit testing on both Model and View components to demonstrate value of MVVM architecture
    * BUnit (Blazor Unit Test) for rendering Blazor components in an XUnit test, and testing areas like Component Parameter validation, presence of certain HTML, etc.

## Design Principles
Application is built around MVVM (Model-View-ViewModel) architecture. This form of separation allows for excellent separation of UI, state data, and external model calls, and is built with Dependency Injection in mind. The breakdown of these three is as follows:
* Model
    * Data-focused functions that are used for manipulating data, handling CRUD operations, and returning meaningful results to the application
* View
    * Collection of UI components that are stripped of as much logic and data as possible.
    * For Blazor projects, these can be separated into:
        * Layout (MainLayout.razor, any other windows that host nested Blazor Components at a top-level)
        * Modals
        * Pages
* ViewModel
    * In-Between Layer that handles calls to Model functions, and hosts data that is bound to Views
    * This keeps your views lean and your Models specific and swappable if injected as an interface
    * Assists in testability as tests can be written fully agnostic of any UI concerns





